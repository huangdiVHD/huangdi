#JavaScript基础
####2019.8.5-2019.8.9
1.<strong>在前端里,HTML是页面的框架,CSS为页面进行布局,JS实现页面的动态功能,它是一门直译式脚本语言</strong>
2. <strong>js的写入方式可以用外部引用,也可以卸载内部,但是需要使用scprit</strong>
3. 变量:
- 可以使字母,数字,下划线
- 但不能是数字开头
- 不能使用关键字,保留字(JS里面的命名,例:div)
- 要严格区分大小写(大小写不同便是2个不同的元素)
- 推荐使用驼峰命名法(例:getEementByld, 即首字母小写,后面的单词开头大写)
- 取名时尽量语义化,看到名字就能知道它代表的意思
4. JS输出方式
- alert();弹窗(警告弹出框)
- console.log()控制台输出
- prompt()弹窗(用户输入语句)
5. 算数运算符 (先乘除后加减,有括号先算括号中的):
- 任何非Number的值要先转换成Number再运算
- 任何值与NaN运算结果都是NaN
- 任何值与String运算,要先转换成String再拼串(例: 
     a=1+2+'3'→3+'3'=33)
- 任何值做-,*,/时都会自动转换成Number
6. typeof()可以用来获取变量的类型
7. 变量的类型:
- String:字符串,字符串相乘没有结果显示为NaN
- Number:数值{NaN (string*string/string*Number时会出现):Not a Number); isNaN(): :任何不能被转换为数值的值，都会让这个函数返回 true。}
- Boolean:布尔值  只有2个 true真,fase假
- undefind:声明了一个变量，但是没有赋值（例如：var a;），此时它的值就是 undefined。
null:空值(在被typeof时返回的是object(对象))
8. 变量转换:
- 其他值转换String:
1). toString();
2). 变量+" ";
3). String();(函数)
- 其他值转换成Number:
1). Number();
2). parseInt():转换整数,自爆流字符节开头的的数字取整,专用于字符串,但不包括开头的0,
3). parseFloat:获取小数和小数后面的值
- 转换成Boolean:Boolean() 函数
1.)数字→布尔值:除了0,NaN都是true
2.)字符串→布尔值:除了空串(" "),都是ture
3.对象,null,undefind转换后为ture
9. 自增:
- 例:   var a=1;
1.) a++  :var a1=a++;此时a1=1,即a为原来的自增前的值
2.)++a  :var a2=++a;此时a2=2.即a为自增后的值
- a++,++a.都会自增同样的值,但是表达值却不同
1.)a++是先将a的值赋予a在自增
2.)++a是先将自增后的值赋予a再自增(可以参考桌面文件夹不凡学院/Js基础/2019.8.5/学习/变量)
- 自减原理同自减
10. 比较:
- == 判断是否等于(不严谨,例 "true"==true)
- === 全等于(完全等于,有你无我)
- !反
- 规则:
1.)对于非数值比较先转换成数字在比较
2.)都是字符串时,不用转换以Unicode编码比较(同一位置开始比较,例:"56">"123" true)
3.)任何值与NaN比较都为fase(假);
11. Date:时间对象,是一个构造函数,需要new出来一个实例对象才能使用,可以用来了解计算机的时间 例var date1 = new Date();
或var date2 = new Date("2017/09/06 09:00:00");(兼容性最强)
- .getTime:时间戳,具有唯一,是从格林威治标准时间到打钱日期所花费的时间毫秒数
获取日期和时间
- Date 对象 有如下方法，可以获取日期和时间：
1). getDate() 获取日 1-31
2). getDay() 获取星期 0-6（0 代表周日，1 代表周一）
3). getMonth() 获取月 0-11（0 代表一月）
4). getFullYear() 获取年份
5). getHours() 获取小时 0-23
6). getMinutes() 获取分钟 0-59
7). getSeconds() 获取秒 0-59
8). getMilliseconds() 获取毫秒 （1s = 1000ms）
12. Match:不是构造函数,不需要创建对象,属于工具类,封装数字运算相关的属性和方法
- Math.abs()	返回绝对值	
- Math.floor()	向下取整（向小取）	
- Math.ceil()	向上取整（向大取）	
- Math.round()	四舍五入取整（正数四舍五入，负数五舍六入）	
- Math.random()	生成 0-1 之间的随机数	不包含 0 和 1
- Math.max(x, y, z)	返回多个数中的最大值	
- Math.min(x, y, z)	返回多个数中的最小值	
- Math.pow(x,y)	返回 x 的 y 次幂	
- Math.sqrt()	对一个数进行开方运算
13. 逻辑运算:
- & 与 :一个为假,所有都为假
- || 或;一个为真所有为真
- ! 反/非
- 非布尔值进行与,或运算时,会先转换为布尔值,然后再运算,单反毁结果是原值(决定整个表达式真假的那个值)
14. 三元运算符:
- 表达式?如果表达式结果为 true 执行这里的代码:如果表达式结果为 false 执行冒号后面的代码;
1)例:
```html
 例5 > 3 ? "5大于3" : "5不大于3";
// 返回'5大于3'
var count = 30;
var price = count > 20 ? 6 : 7;
console.log(price);
// 可以理解为 if else 的另一种写法
```
15. if,switch为条件判断语句,条件分置于句
16. for,while为循环语句
- while为先判断再运行
- do while为先运行在判断
17. break:
- 用来停止switch语句或整个循环语句
- 用来终止离它最近的循环语句
18. continue:
- 用来调过此次循环
- 只会对默认离它最近的循环起作用
#####19. 对于if,for的应用,混合应用
- 要活用逻辑运算符
- 对于列出某一数字能够整除的数字,以var==i和for将其内的数都列出来进行取余,余数为0即成立
```html
var a =prompt("请输入");
for(var i=1;i<=a;i++){
if(a%i=0){
console.log(i);
}
}
```
- 对于取余a%b==c要灵活运用
- 对于求和求乘积要添加累加器(累加器说白了就是先声明一个值为0的量然后将变量I加到上面)例
```html
求和 var a=0;
  for(var i=1;i<=a;i++){
      a=a+i;(a+=i);
      console.log(a);
  }
  在求和时a=0不影响初始值,为1影响
  求乘积时a=0则无效(a=a*i)只能为1
```
- 对于判断质数要声明一个量,当做计数器,在if中一次判断+1(++a),for则进行将数全部列举
1). 以求质数为列,他只有2个因数,因此计数器最大且只能为2,符合a=2的数则是质数
1.Array:数组
- 内置对象,普通对象们可以根据属性名获取值
- 需要使用索引,获取元素的值
- 数组当中没一个元素都有对应的下标(索引).下标从0开始
- 数组的元素可以使任意的数据类型
- 数组通常是表达同一类数据的集合
- 数组具有增删改查四种基本操作()都是通过数组下标进行操作)
```html
例
var arr=[1,2,3,4](下标0-3)
增: arr[4]=5;   在下标位4出添加元素5
   push():在最后加上一个元素(数组的末尾)
   unshift()在数组第一个元素之前添加一个元素.
   二者都是修改了原数组,返回值为修改后的数组长度

查:console.log(arr[3]);  控制台输出4,即获取了下标3的值=4

改: arr[1]=33; 即将下表1的值由2变为33(不仅能修改数组的值也
可以修改数组的长度length)

例:原长度为4,修改为6后,多出的2个长度值为null
反之,若从4改为3 ,则会删除多出的长度,从后向前删除

删: shift():删除数组第一个元素
pop():删除数组最后一个元素.
二者都是修改了原数组,并且返回值都是删除的那个元素
```
20. 数组
- 遍历数组:
1).  查找元素需要用到的下标
2).遍历下标(0-length)
3). 应用下标arr[i]来进行判断
- 对于数组的平均数,需要先对数组进行求和在平均
- 对于数组求和,要先遍历数组,先将下标找出再将值拿出来然后应用求和的思想定义一个指,然后var a=a+arr[i];

21.冒泡排序:
- 会重复地走访要排序的元素列,一次比较两个相邻的元素(它们的顺序,从大到小,首字母从A-Z,如果有错误则会把他们交换过来,
- 走访元素的工作室重复地进行,直到没有相邻的元素需要交换即元素已经完成排序)
- 越大的元素会经由交换慢慢浮到数列的顶端(升序或降序)
```html
例:  var arr = [23, 45, 12, 9, 47, 11];
冒泡排序
        // for (var i = 0; i < arr.length - 1; i++) {
        //     if (arr[i] > arr[i + 1]) {
        //         // 顺序错误
        //         // 交换位置
        //         // 先把之前arr[i]的值保存下来
        //         var temp = arr[i];
        //         arr[i] = arr[i + 1]; // arr[i]已经发生了改变
        //         arr[i + 1] = temp;
        //     }
        // }
        // 这段代码  要执行  arr.length-1次
冒泡排序优化
        for (var j = 1; j < arr.length; j++) {
            // 外层 for 循环 控制 轮次
            for (var i = 0; i < arr.length - j; i++) {
                // 内层 for 循环  负责 找出本轮最大值
                if (arr[i] > arr[i + 1]) {
                    // 顺序错误
                    // 交换位置
                    // 先把之前arr[i]的值保存下来
                    var temp = arr[i];
                    arr[i] = arr[i + 1]; // arr[i]已经发生了改变
                    arr[i + 1] = temp;
                }
            }
        }
        console.log(arr);
```
22. 函数:function
- 命名规定和变量的命名规定是一样的
- 参数可选
- 函数表达式:将匿名函数的赋值给一个变量
- 形参:在函数的()中来指定一个或多个形参function(a,b,c),多形参之间使用逗号隔开,声明形参就相当于在函数内部声明了对应的变量,并不赋值
- 实参:在调用函数式可以在()中定义实参arr(1);此时1就是实参.实参会赋值给函数中对应的形参(形参,实参的个数相同)
```html
例: function arr(str){
    alert(str);
}
arr(1)
str形参,1实参
```
- return:函数的返回值
1). return之后的代码不会再执行m,函数遇到return会执行结束
2). 不是所有的函数都有返回值
3).但是返回值很重要
4).返回值可以是任意的数据类型，可以是对象，也可以是函数。
- fn()：调用函数。相当于获取了函数的返回值。
- fn：函数对象。相当于直接获取了函数对象。
23. 作用域
- 全局作用域:里面的变量都是全局变量,在页面的任意位置都可以访问
- 局部作用域(局部变量):在局部作用域中声明的变量,函数内部的声明的变量,只能在内部使用,若在函数要访问全局变量可以使用window对象(window.)
- 变量遵守就近原则,先找自身作用域,找不到再找父级作用域查找(上一级作用域),弱势全局作用域也没有找到便会报错
24. 递归
- 必须要有条件,没有条件它会一直地跪下去,无法进行输出
- 条件是让函数内部满足他时停止然后输出
25. 声明
- 函数声明放在上面会在函数代码执行前执行即undefined
- 变量声明若不使用var,即变量成为全局变量,声明提前
- 若使用var,表明变量在代码执行前已经被声明但没有赋值
```html
例: console.log(a);//undefind,被声明没有赋值
  var a=10;

  console.log(b);//bis  not defind 没有声明提升
  b=2;
  console.log(b);//2 b=全局变量
```
26. 函数里的代码不调用是不会执行
27. 对象:用来封装信息,用来描述一个事物
28. 构造函数:
- 和普通函数一笔没构造函数首字母大写,在使用时用new
- 在构造函数中,this的指向对象是创造出的实例对象
- 遍历对象可以使用  in 来进行,在输出时必须加[]
29. JSON:
- 数组,对象等是不可以进行传输的,但是可以借助JSON的2个方法来进行传输
1). JSON.Stringfy();将数组,对象等变为文本
2). JSON.porse();将文本变为数组,对象等
30. 数组的高级对象
- forEach():遍历数组,对多科协三个参数,第一个必须要有,另外两个可以根据需要来使用
1). 即  forEach(item,index,arr);,item:遍历数组的元素,index:遍历数组的元素对应的下标,arr你遍历的数组
- 翻转数组:reverse
- 截取数组(slice):
1). 例:arr.slice(a,b);a时开始的索引,b是结束的索引
2). slice并不包括b的值,即输出的是a-b-1的对应的下标的元素
3). arr.slice(0)即复制数组,并不影响原数组
- 删除或替换数组中的元素:splice()
1).arr.splice(a,b,c)替换:a从哪个索引开始替换,b从替换开始的地方a开始,要替换几个元素.C:参数,即修改的值可以一个或多个
2).删除:即arr.splice(a,b),不写后面的参数,即表示删除
- 返回元素在宿主的索引:
1).indexof:从前开始匹配
2).lastIndexof:从后开始匹配
3).若是输入一个数组中找不到的元素,则返回-1
- 排序sort
1). 当不带有参数是以unicode编码进行排序
2).带参数时,按照指定的排序规则进行(参数可以是函数)
```html
例:  arr.sort(function(a,b){
    return a-b;
})
a-b:从小到大排序,反之从大到小排序
其中当结果>0时元素位置交换,=0,<0时元素位置都不会变动
并且对于对象是可以进行设置条件(即和函数一般操作)
例: console.log(arr2);
        var users = [{
                name: '张三',
                age: 20,
                height: 176
            },
            {
                name: '李四',
                age: 19,
                height: 175
            },
            {
                name: '王五',
                age: 22,
                height: 172
            },
            {
                name: '赵六',
                age: 18,
                height: 174
            },
            {
                name: '陈琦',
                age: 18,
                height: 178
            },

        ]

        // 按照年龄从小到大排序
        // 年龄相同时  按身高从大到小排
        users.sort(function (a, b) {
            if (a.age === b.age) {
                return b.height - a.height
            } else {
                return a.age - b.age;
            }
        })
        console.log(users);
```
- 字符串的高级方法
1). charAt();返回指定位置的字符(从0开始),charCodeAT():和charAt一样不过是返回指定位置的字符的Uncode编码
2).indexof("a"):返回"a"在元素中的位置由前→后开始,lastIndexof("a"),一样只是是由后→前开始
3).截取:slice(a,b):a-b-1的元素,substr(a,b),a-b的元素
4).toUpperCase:字符串大变小,toLowerCase()字符串小变大
5).concat:连接字符串,例:var a=b.concat(c);
31. JavaScript
	- JavaScript负责页面中的的行为。
	- 它是一门运行在浏览器端的脚本语言。
	- JS的编写的位置
		1.可以编写到标签的指定属性中
			<button onclick="alert('hello');">我是按钮</button>
			<a href="javascript:alert('aaa');">超链接</a>
			
		2.可以编写到script标签中   *****
			<script type="text/javascript">
				//编写js代码
			</script>
			
		3.可以将代码编写到外部的js文件中，然后通过标签将其引入 *****
			<script type="text/javascript" src="文件路径"></script>
			
	- 输出语句
		- alert("要输出的内容");
			- 该语句会在浏览器窗口中弹出一个警告框
			
		- document.write("要输出的内容");
			- 该内容将会被写到body标签中，并在页面中显示
			
		- console.log("要输出的内容");
			- 该内容会被写到开发者工具的控制台中
			
	- 基本的语法
		- 注释
			- 单行注释
				//注释内容
			- 多行注释
				/*
					注释内容
				*/
				
		- JS严格区分大小写	
		- JS中每条语句以分号(;)结尾
		- JS中会自动忽略多个空格和换行，所以我们可以利用空格和换行对代码进行格式化。
		
	- 字面量和变量
		- 字面量
			- 字面量实际上就是一些固定的值，比如 1 2 3 4 true false null NaN "hello"
				字面量都是不可以改变的。
			- 由于字面量不是很方便使用，所以在JS中很少直接使用字面量
		
		- 变量
			- 变量可以用来保存字面量，并且可以保存任意的字面量
			- 一般都是通过变量来使用字面量，而不直接使用字面量，而且也可以通过变量来对字面量进行一个描述
			- 声明变量
				- 使用var关键字来声明一个变量
				var a;
				var b;
				var c;
				
			- 为变量赋值
				a = 1;
				b = 2;
				c = 3;
				
			- 声明和赋值同时进行 *****
				var d = 456;
				var e = 789;
				
	- 标识符
		- 在JS中所有的可以自主命名的内容，都可以认为是一个标识符，
			是标识符就应该遵守标识符的规范。
		- 比如：变量名、函数名、属性名
		- 规范：
			1.标识符中可以含有字母、数字、_、$
			2.标识符不能以数字开头
			3.标识符不能是JS中的关键字和保留字
			4.标识符一般采用驼峰命名法
				xxxYyyZzz
32. 文档流
	- 所有的元素默认情况下都是在文档流中存在的
	- 文档流是网页的最底层
	- 元素在文档流中的特点：
		- 块元素
			1.默认宽度是父元素的全部
			2.默认高度被内容（子元素）撑开
			3.在页面中自上而下垂直排列
		- 内联元素
			1.默认高度和宽度都被内容撑开
			2.在页面中自左向右水平排列，如果一行不足以容下所有的元素
				则换到下一行继续从左向右
				
33. 浮动
	- 使用float来设置元素的浮动
	- 可选值：
		none 默认值，元素不浮动，就在文档流中
		left 元素向页面的左侧浮动
		right 元素向页面的右侧浮动
	- 浮动特点：
		1.元素设置浮动以后，会完全脱离文档流，并向页面的左上或右上浮动。
				直到遇到父元素的边框或其他的父元素时则停止浮动。
		2.如果浮动元素上边是一个没有浮动的块元素，元素不会超过该块元素。
		3.浮动元素的浮动位置不能超过他上边浮动的兄弟元素，最多一边齐
		4.浮动元素不会覆盖文字，文字会围绕在浮动元素的周围，所以可以通过浮动来实现文字环绕图片的效果。
		
	- 浮动以后元素会完全脱离文档流，脱离文档流以后元素会具有如下特点：
		1.块元素不独占一行
		2.块元素的宽度和高度都被内容撑开
		3.元素不在文档流占用位置
		4.内联元素会变成块元素
		
	- <strong>高度塌陷</strong>
		- 在文档流中元素的高度默认被子元素撑开，当子元素浮动时，子元素会脱离文档流，
			此时将不能撑起父元素的高度，会导致父元素的高度塌陷。父元素高度塌陷会导致其他元素的位置上移，导致页面的布局混乱。
		- 可以通过开启元素的BFC来处理高度塌陷的问题。
			- BFC叫做Block Formatting Context
			- 它是一个隐含属性，默认情况是关闭，当开启以后元素会具有如下的特性：
				1.父元素的垂直外边距不会和子元素重叠
				2.开启BFC的元素不会被浮动元素覆盖
				3.父元素可以包含浮动的子元素 ******
			- 开启BFC的方式很多：
				1.设置元素浮动
				2.设置元素绝对定位
				3.设置元素为inline-block
				4.将元素的overflow设置为一个非默认值
			- 一般我们采取副作用比较小的方式
				overflow:hidden;
				
34. 定位
	- 通过定位可以将元素摆放到页面的任意位置
	- 使用position来设置元素的定位
		- 可选值：
			- static 默认值 元素不开启定位
			- relative 开启元素的相对定位
			- absolute 开启元素的绝对定位
			- fixed 开启元素的固定定位
			
		- 相对定位
			1.相对于元素自身在文档流中的位置进行定位
			2.相对定位的元素不会脱离文档流，定位元素的性质不会改变，块还是块，内联还是内联
			3.如果不设置偏移量，元素不会发生任何的变化
			4.会提升元素的层级
			
		- 绝对定位
			1.相对于离它最近的开启了定位的祖先元素进行定位，如果祖先元素都没有开启定位则相对于浏览器窗口进行定位。
			2.绝对定位会使元素完全脱离文档流，会改变元素的性质，内联变成块元素，块元素的宽度被内容撑开
			3.绝对定位的元素如果不设置偏移量，元素的位置不会发生变化
			4.会提升元素的层级
			
		- 固定定位
			- 固定定位也是一种绝对定位，它的大部分特点都和绝对定位是相同的。
			- 不同的是：
				- 固定定位永远相对于浏览器窗口进行定位
				- 固定定位会固定在浏览器的指定的位置，不会随页面一起滚动
				
		- 偏移量
			- 当元素开启了定位以后，可以通过四个偏移量来设置元素的位置
				top：相对于定位位置的顶部的偏移量
				bottom：相对于定位位置的底部的偏移量
				left：相对于定位位置的左侧的偏移量
				right：相对于定位位置的右侧的偏移量
				
			- 一般只需要使用两个值即可给元素进行定位
				top left
				top right
				bottom left
				bottom right
				
			- 偏移量也可以指定一个负值，如果是负值则元素会向相反的方向移动
			
		- 层级
			- 当元素开启定位以后，可以通过z-index来设置层级，
				它需要一个正整数作为参数，值越大层级越高，层级越高越优先显示
				如果层级一样，则后边的会盖住前边的，父元素永远都不会盖住子元素。
				
			- 文档流 < 浮动 < 定位	
			
35. 元素的透明
			使用opacity来设置元素的透明度
				- 需要一个0-1之间的值
				- 0 表示完全透明
				- 1 表示完全不透明
				
			IE8及以下的浏览器不支持该样式，需要使用如下方式来设置
				filter:alpha(opacity=透明度);
				- 需要一个0-100之间的值
				- 0 表示完全透明
				- 100 表示完全不透明